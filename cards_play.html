<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Partida — Cartas Quechua</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{ --primary:#dc2626; --muted:#6b7280; font-family:Poppins,system-ui,Arial; --card-size:88px; }
    body{ margin:0;background:#fafafa;color:#111; }
    header{ background:var(--primary); color:#fff; padding:12px 16px; display:flex;align-items:center;justify-content:space-between; position:relative; }
    main{ padding:16px; max-width:1200px;margin:18px auto; position:relative; }
    .panel{ background:#fff;padding:14px;border-radius:10px;box-shadow:0 8px 24px rgba(2,6,23,0.06); min-height:520px; }

    /* TOP-LEFT participants bar (fixed inside main) */
    .participants-bar{
      position:absolute;
      top:8px;
      left:8px;
      display:flex;
      gap:10px;
      z-index:30;
    }
    .avatar-wrap{ position:relative; width:56px; height:56px; }
    .avatar{ width:56px; height:56px; border-radius:50%; object-fit:cover; border:3px solid rgba(255,255,255,0.12); box-shadow:0 6px 18px rgba(0,0,0,0.12); display:block; }
    .orb {
      position:absolute; inset:0; border-radius:50%; pointer-events:none;
      box-shadow: 0 0 0 4px rgba(0,0,0,0.08) inset;
    }
    .orb.active::after{
      content:''; position:absolute; inset:-6px; border-radius:50%;
      background: radial-gradient(circle at 35% 20%, rgba(99,255,149,0.95), transparent 10%), rgba(0,0,0,0);
      box-shadow: 0 0 0 3px rgba(34,197,94,0.9), 0 6px 18px rgba(16,185,129,0.12);
      animation: pulse 1.8s infinite;
      filter: blur(0.6px);
    }
    @keyframes pulse{ 0%{ transform: scale(0.96); opacity:0.95 } 50%{ transform: scale(1.04); opacity:1 } 100%{ transform: scale(0.96); opacity:0.95 } }

    /* center area */
    .center-area{ display:flex; align-items:center; justify-content:center; gap:20px; margin-top:18px; min-height:260px; }
    .deck{ width:84px; height:120px; border-radius:8px; background:linear-gradient(180deg,#f3f4f6,#e5e7eb); display:flex;align-items:center;justify-content:center; font-weight:700; color:#666; border:1px dashed #ddd; cursor:pointer; }
    .discard{ width:120px; height:160px; display:flex;align-items:center;justify-content:center; position:relative; }

    /* card look */
    .card {
      width: var(--card-size);
      height: var(--card-size);
      min-width: var(--card-size);
      min-height: var(--card-size);
      border-radius:12px;
      display:flex;align-items:center;justify-content:center;
      font-weight:800; font-size:20px; color:#111;
      box-shadow:0 8px 20px rgba(2,6,23,0.08);
      cursor:pointer; user-select:none;
    }
    .card .inner{ width:100%; height:100%; display:flex;align-items:center;justify-content:center; border-radius:10px; background:#fff; }
    .card.color-red .inner{ background:linear-gradient(180deg,#fee2e2,#fecaca); }
    .card.color-green .inner{ background:linear-gradient(180deg,#ecfdf5,#bbf7d0); }
    .card.color-blue .inner{ background:linear-gradient(180deg,#eef2ff,#c7d2fe); }
    .card.color-yellow .inner{ background:linear-gradient(180deg,#fffbeb,#fef3c7); }
    /* special rainbow border */
    .card.special {
      padding:3px;
      background: conic-gradient(from 0deg, red, orange, yellow, green, blue, purple, red);
      border-radius:14px;
    }
    .card.special .inner{ background:#fff; border-radius:10px; height:100%; width:100%; display:flex;align-items:center;justify-content:center; font-weight:900; }

    /* bottom hand area */
    .hand-area{ position:absolute; left:0; right:0; bottom:12px; display:flex; justify-content:center; pointer-events:auto; z-index:25; }
    .hand{ display:flex; gap:10px; padding:10px 16px; background:linear-gradient(180deg,rgba(255,255,255,0.9),rgba(250,250,250,0.9)); border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.06); }

    /* played card animation center overlay */
    .center-play {
      position:absolute; left:50%; top:46%; transform:translate(-50%,-50%); z-index:40; pointer-events:none;
      transition: transform .28s ease, opacity .28s ease;
      opacity:0;
    }
    .center-play.show{ opacity:1; transform:translate(-50%,-50%) scale(1); }
    .center-play.hide{ opacity:0; transform:translate(-50%,-10%) scale(0.8); }

    /* controls */
    .controls{ position:absolute; right:20px; top:90px; display:flex; flex-direction:column; gap:10px; z-index:22; }
    .controls .btn{ padding:8px 12px; border-radius:8px; border:0; background:var(--primary); color:#fff; cursor:pointer; }

    /* results toast */
    .winner-toast{ position:fixed; top:18px; left:50%; transform:translateX(-50%); background:linear-gradient(90deg,#10b981,#059669); color:#fff; padding:12px 18px; border-radius:10px; z-index:9999; box-shadow:0 12px 30px rgba(0,0,0,0.18); font-weight:700; }
    @media (max-width:820px){ .participants-bar{ left:10px; } .hand{ overflow:auto; } .card{ width:72px; height:72px } }
  </style>
</head>
<body>
  <header>
    <div><strong>Partida de Cartas</strong></div>
    <div><a href="dashboard.html" style="color:#fff;text-decoration:none">Salir</a></div>
  </header>

  <main>
    <div class="panel" id="panel">
      <!-- participants avatars -->
      <div class="participants-bar" id="participantsBar"></div>

      <!-- center area: deck (right), discard (center) -->
      <div class="center-area">
        <div class="deck" id="deckCount" title="Mazo (click para robar)">Mazo</div>
        <div class="discard" id="discardArea"></div>
        <div class="controls" id="controls">
          <button class="btn" id="drawBtn">Robar</button>
          <select id="wildColorSelect" title="Color para comodín">
            <option value="">Color (comodín)</option>
            <option value="red">Rojo</option>
            <option value="green">Verde</option>
            <option value="blue">Azul</option>
            <option value="yellow">Amarillo</option>
          </select>
          <button class="btn" id="unoBtn" title="Declarar UNO" style="background:#f59e0b">UNO</button>
          <button class="btn" id="challengeBtn" title="Desafiar +4" style="background:#06b6d4;display:none">Challenge +4</button>
        </div>
      </div>

      <!-- center-play animation -->
      <div id="centerPlay" class="center-play"></div>

      <!-- bottom hand -->
      <div class="hand-area">
        <div id="hand" class="hand"></div>
      </div>

      <!-- status and results -->
      <div id="turnInfo" style="margin-top:6px" class="small"></div>
      <div id="results" style="margin-top:12px;"></div>
    </div>
  </main>

  <div id="winnerToast" class="winner-toast" style="display:none"></div>

  <script>
  (async function(){ 
     function qs(name){ const url = new URL(window.location.href); return url.searchParams.get(name); }
     const roomId = (qs('room')||'').toUpperCase();
     document.getElementById('roomId')?.textContent = roomId;
     const participantsBar = document.getElementById('participantsBar');
     const handEl = document.getElementById('hand');
     const discardArea = document.getElementById('discardArea');
     const drawBtn = document.getElementById('drawBtn');
     const wildSelect = document.getElementById('wildColorSelect');
     const centerPlay = document.getElementById('centerPlay');
     const winnerToast = document.getElementById('winnerToast');
     const turnInfo = document.getElementById('turnInfo');
     const resultsEl = document.getElementById('results');
     const deckCountEl = document.getElementById('deckCount');
 
     let profile = null;
     try { profile = JSON.parse(sessionStorage.getItem('g_profile') || localStorage.getItem('g_profile') || 'null'); } catch(e){ profile = null; }
     if (!profile) { alert('Necesitas iniciar sesión con Google para jugar.'); window.location.href='dashboard.html'; return; }
 
     let gameState = null;
     let poll = null;
 
     // helpers
     function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, (m)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
     function colorClass(c){ if (!c) return 'wild'; return 'color-'+c; }
 
     // render participants avatars top-left
     function renderParticipants(room){
       participantsBar.innerHTML = '';
       if (!room || !room.participants) return;
       const currentEmail = room.gameState ? room.gameState.participants[room.gameState.currentIndex] : null;
       room.participants.forEach(p=>{
         const wrap = document.createElement('div'); wrap.className='avatar-wrap';
         const img = document.createElement('img'); img.className='avatar'; img.src = p.picture || 'https://via.placeholder.com/56';
         img.alt = p.name || p.email || '';
         const orb = document.createElement('div'); orb.className='orb';
         if (p.email === currentEmail) orb.classList.add('active');
         wrap.appendChild(img); wrap.appendChild(orb);
         participantsBar.appendChild(wrap);
       });
     }
 
     // render top discard
     function renderTop(card){
       discardArea.innerHTML = '';
       if (!card) return;
       const el = document.createElement('div');
       const isSpecial = (card.type === 'wild' || (card.type==='action' && (card.value==='+2')));
       el.className = 'card ' + (isSpecial ? 'special' : (card.color ? 'color-'+card.color : 'wild'));
       const inner = document.createElement('div'); inner.className='inner';
       inner.textContent = card.type==='number' ? card.value : card.value;
       el.appendChild(inner);
       discardArea.appendChild(el);
       // also show top as center-play flash
       showCenterPlay(card);
     }
 
     // show animated center played card
     function showCenterPlay(card){
       centerPlay.innerHTML = '';
       const el = document.createElement('div');
       const isSpecial = (card.type === 'wild' || (card.type==='action' && (card.value==='+2')));
       el.className = 'card ' + (isSpecial ? 'special' : (card.color ? 'color-'+card.color : 'wild'));
       const inner = document.createElement('div'); inner.className='inner';
       inner.textContent = card.type==='number' ? card.value : card.value;
       el.appendChild(inner);
       centerPlay.appendChild(el);
       centerPlay.classList.add('show');
       setTimeout(()=> centerPlay.classList.remove('show'), 700);
     }
 
     // render player's hand (only visible to current profile)
     function renderHand(){
       handEl.innerHTML = '';
       if (!gameState) return;
       const myHand = gameState.hands[profile.email] || [];
       myHand.forEach((c, idx)=>{
         const wrap = document.createElement('div');
         const isSpecial = (c.type === 'wild' || (c.type==='action' && (c.value==='+2')));
         wrap.className = 'card ' + (isSpecial ? 'special' : (c.color ? 'color-'+c.color : 'wild'));
         const inner = document.createElement('div'); inner.className='inner';
         inner.textContent = c.type==='number' ? c.value : c.value;
         wrap.appendChild(inner);
         // badge count if many cards identical? skipped
         wrap.addEventListener('click', ()=> onPlayCard(idx));
         handEl.appendChild(wrap);
       });
       // show count of deck
       if (gameState.deck) {
         deckCountEl.textContent = 'Mazo: ' + gameState.deck.length;
       }
     }
 
     // poll state
     async function pollState(){
       try {
         const r = await fetch('/api/room/' + roomId);
         const j = await r.json();
         if (!j || !j.ok){ turnInfo.textContent = 'Error cargando sala'; return; }
         const room = j.room;
         renderParticipants(room);
         updateChallengeUI(room);
         if (room.status === 'started' && room.gameState){
           gameState = room.gameState;
           renderTop(gameState.discard[gameState.discard.length-1]);
           renderHand();
           const current = gameState.participants[gameState.currentIndex];
           turnInfo.textContent = 'Turno de: ' + current + (current===profile.email ? ' (Tu turno)' : '');
           // if finished, show results
         }
         if (room.status === 'finished' && room.results){
           showFinished(room.results);
         }
       } catch(e){
         console.warn('poll error', e);
         turnInfo.textContent = 'Conexión perdida';
       }
     }
 
     // play card clicked
     async function onPlayCard(handIndex){
       if (!gameState) return;
       const currentEmail = gameState.participants[gameState.currentIndex];
       if (currentEmail !== profile.email) { alert('No es tu turno'); return; }
       const myHand = gameState.hands[profile.email] || [];
       const card = myHand[handIndex];
       if (!card) return;
       let chosen = null;
       if (card.type === 'wild'){
         chosen = wildSelect.value;
         if (!chosen){
           chosen = prompt('Elige color: red, green, blue, yellow') || '';
         }
         if (!['red','green','blue','yellow'].includes(chosen)) {
           alert('Debes elegir un color válido');
           return;
         }
       }
       // optimist visual
       showCenterPlay(card);
       // enviar jugada al servidor
       try {
         const resp = await fetch('/api/play-card', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ roomId, email: profile.email, card: card, chosenColor: chosen })
         });
         const j = await resp.json().catch(()=>null);
         if (!j || !j.ok) {
           alert('Movimiento rechazado: ' + (j && j.error ? j.error : 'error'));
           await pollState();
           return;
         }
         if (j.finished) {
           if (j.results) showFinished(j.results);
           try { localStorage.setItem('last_card_results', JSON.stringify(j.results)); } catch(e){}
           showWinnerAndRedirect(j.results);
         } else {
           // actualizar estado local
           if (j.gameState) {
             gameState = j.gameState;
             await pollState();
           } else {
             await pollState();
           }
         }
       } catch (err) {
         console.error('play-card error', err);
         alert('Error enviando la jugada');
         await pollState();
       }
     }
 
     async function onDraw(){
       try {
         const resp = await fetch('/api/draw-card', {
           method:'POST',
           headers:{ 'Content-Type':'application/json' },
           body: JSON.stringify({ roomId, email: profile.email })
         });
         const j = await resp.json().catch(()=>null);
         if (!j || !j.ok) {
           alert('No se pudo robar: ' + (j && j.error ? j.error : 'error'));
           return;
         }
         // actualizar estado tras robar
         if (j.gameState) {
           gameState = j.gameState;
         }
         await pollState();
       } catch (err) {
         console.error('draw-card error', err);
         alert('Error al robar carta');
       }
     }
 
     function showFinished(results){
       // store results and show
       try { localStorage.setItem('last_card_results', JSON.stringify(results)); } catch(e){}
       showWinnerAndRedirect(results);
     }
 
     function showWinnerAndRedirect(results){
       const winner = results && results.length ? (results[0].name || results[0].email) : 'Jugador';
       winnerToast.textContent = '¡' + winner + ' ganó la partida!';
       winnerToast.style.display = 'block';
       // mostrar tabla resumida en la misma página (opcional)
       resultsEl.innerHTML = '<h4>Resultados</h4>';
       const table = document.createElement('table');
       const thead = document.createElement('thead');
       thead.innerHTML = '<tr><th>#</th><th>Jugador</th><th>Score</th><th>XP</th></tr>';
       table.appendChild(thead);
       const tbody = document.createElement('tbody');
       results.forEach(r => {
         const tr = document.createElement('tr');
         tr.innerHTML = `<td>${r.rank}</td><td>${escapeHtml(r.name||r.email)}</td><td>${r.score||'--'}</td><td>${r.xpEarned||0}</td>`;
         tbody.appendChild(tr);
       });
       table.appendChild(tbody);
       resultsEl.appendChild(table);
 
       setTimeout(()=> {
         // redirigir al lobby para ver resumen
         window.location.href = 'cards.html';
       }, 4200);
     }
 
     // new helpers: declare UNO and challenge
     async function declareUno(){
       try {
         await fetch('/api/declare-uno', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ roomId, email: profile.email })});
         alert('UNO declarado');
       } catch(e){ console.warn(e); }
     }
 
     async function challengePlus4(){
       try {
         const resp = await fetch('/api/challenge', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ roomId, challengerEmail: profile.email })});
         const j = await resp.json();
         if (j && j.ok){
           alert('Resultado challenge: ' + (j.result || 'ok'));
           // update local state
           if (j.gameState) gameState = j.gameState;
           await pollState();
         } else {
           alert('Challenge failed: ' + (j && j.error ? j.error : 'error'));
         }
       } catch(e){ console.warn(e); alert('Error en challenge'); }
     }
 
     // integrate UI updates: show challenge button if awaitingChallenge and I'm the current player
     function updateChallengeUI(room){
       const challengeBtn = document.getElementById('challengeBtn');
       if (!room || !room.gameState) { challengeBtn.style.display = 'none'; return; }
       const gs = room.gameState;
       const awaiting = !!gs.awaitingChallenge;
       const current = gs.participants[gs.currentIndex];
       if (awaiting && current === profile.email) challengeBtn.style.display = 'inline-block';
       else challengeBtn.style.display = 'none';
     }
 
     // override pollState to also call updateChallengeUI
     async function pollState(){
       try {
         const r = await fetch('/api/room/' + roomId);
         const j = await r.json();
         if (!j || !j.ok){ turnInfo.textContent = 'Error cargando sala'; return; }
         const room = j.room;
         renderParticipants(room);
         updateChallengeUI(room);
         if (room.status === 'started' && room.gameState){
           gameState = room.gameState;
           renderTop(gameState.discard[gameState.discard.length-1]);
           renderHand();
           const current = gameState.participants[gameState.currentIndex];
           turnInfo.textContent = 'Turno de: ' + current + (current===profile.email ? ' (Tu turno)' : '');
         }
         if (room.status === 'finished' && room.results){
           showFinished(room.results);
         }
       } catch(e){
         console.warn('poll error', e);
         turnInfo.textContent = 'Conexión perdida';
       }
     }
 
     // bind UNO/challenge buttons
     document.getElementById('unoBtn').addEventListener('click', declareUno);
     document.getElementById('challengeBtn').addEventListener('click', challengePlus4);
 
     // eventos
     drawBtn.addEventListener('click', onDraw);
     deckCountEl.addEventListener('click', onDraw);
 
    // iniciar polling de estado
    await pollState();
    poll = setInterval(pollState, 1400);
 
  })();
  </script>
</body>
</html>
